# Migration Guide: dir_spec 0.1.x â†’ 0.2.0

This guide covers all breaking changes and provides step-by-step migration instructions for upgrading from dir_spec
0.1.x to 0.2.0.

## Summary of Breaking Changes

1. **Return type changed**: All methods now return `Option<PathBuf>` instead of `Result<PathBuf>`
2. **Removed deprecated methods**: All `*_dir()` variants have been removed
3. **Removed dependencies**: No longer uses `eyre` or `libc` dependencies
4. **Simplified error handling**: Use Option pattern matching instead of Result
5. **Runtime directory behavior changed**: Linux now uses `$TMPDIR` then `/tmp` fallback instead of `/run/user/{uid}`

## Dependency Changes

### Before (0.1.x)

```toml
[dependencies]
dir_spec = "0.1.0"
eyre = "0.6"  # Required for error handling
libc = "1.0"  # Used internally by dir_spec
```

### After (0.2.0)

```toml
[dependencies]
dir_spec = "0.2.0"
# No additional dependencies required - zero dependency crate!
```

## Method Signature Changes

All public methods have changed their return type:

| Method       | 0.1.x Return Type | 0.2.0 Return Type |
|--------------|-------------------|-------------------|
| All methods  | `Result<PathBuf>` | `Option<PathBuf>` |

## Removed Methods

The following deprecated methods have been removed completely:

| Removed Method      | Replacement      |
|---------------------|------------------|
| `desktop_dir()`     | `desktop()`      |
| `documents_dir()`   | `documents()`    |
| `download_dir()`    | `downloads()`    |
| `music_dir()`       | `music()`        |
| `pictures_dir()`    | `pictures()`     |
| `publicshare_dir()` | `publicshare()`  |
| `runtime_dir()`     | `runtime()`      |
| `templates_dir()`   | `templates()`    |
| `videos_dir()`      | `videos()`       |

## Migration Patterns

### Pattern 1: Basic Usage with `?` Operator

**Before (0.1.x):**

```rust
use dir_spec::Dir;
use eyre::Result;

fn main() -> Result<()> {
    let config = Dir::config_home()?;
    let cache = Dir::cache_home()?;
    let home = Dir::home()?;
    
    println!("Config: {}", config.display());
    println!("Cache: {}", cache.display());
    println!("Home: {}", home.display());
    
    Ok(())
}
```

**After (0.2.0):**

```rust
use dir_spec::Dir;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = Dir::config_home().ok_or("Failed to get config directory")?;
    let cache = Dir::cache_home().ok_or("Failed to get cache directory")?;
    let home = Dir::home().ok_or("Failed to get home directory")?;
    
    println!("Config: {}", config.display());
    println!("Cache: {}", cache.display());
    println!("Home: {}", home.display());
    
    Ok(())
}
```

### Pattern 2: Pattern Matching

**Before (0.1.x):**

```rust
use dir_spec::Dir;

match Dir::config_home() {
    Ok(path) => println!("Config directory: {}", path.display()),
    Err(e) => eprintln!("Error: {}", e),
}
```

**After (0.2.0):**

```rust
use dir_spec::Dir;

match Dir::config_home() {
    Some(path) => println!("Config directory: {}", path.display()),
    None => eprintln!("Could not determine config directory"),
}
```

### Pattern 3: If-Let Pattern

**Before (0.1.x):**

```rust
use dir_spec::Dir;

if let Ok(config_dir) = Dir::config_home() {
    println!("Using config directory: {}", config_dir.display());
}
```

**After (0.2.0):**

```rust
use dir_spec::Dir;

if let Some(config_dir) = Dir::config_home() {
    println!("Using config directory: {}", config_dir.display());
}
```

### Pattern 4: Fallback Values

**Before (0.1.x):**

```rust
use dir_spec::Dir;
use std::path::PathBuf;

let config_dir = Dir::config_home().unwrap_or_else(|_| {
    PathBuf::from("./config")
});
```

**After (0.2.0):**

```rust
use dir_spec::Dir;
use std::path::PathBuf;

let config_dir = Dir::config_home().unwrap_or_else(|| {
    PathBuf::from("./config")
});
```

### Pattern 5: Multiple Directory Resolution

**Before (0.1.x):**

```rust
use dir_spec::Dir;
use eyre::Result;

fn setup_directories() -> Result<()> {
    let config = Dir::config_home()?;
    let cache = Dir::cache_home()?;
    let data = Dir::data_home()?;
    
    std::fs::create_dir_all(&config)?;
    std::fs::create_dir_all(&cache)?;
    std::fs::create_dir_all(&data)?;
    
    Ok(())
}
```

**After (0.2.0):**

```rust
use dir_spec::Dir;
use std::io;

fn setup_directories() -> Result<(), Box<dyn std::error::Error>> {
    let config = Dir::config_home().ok_or("No config directory")?;
    let cache = Dir::cache_home().ok_or("No cache directory")?;
    let data = Dir::data_home().ok_or("No data directory")?;
    
    std::fs::create_dir_all(&config)?;
    std::fs::create_dir_all(&cache)?;
    std::fs::create_dir_all(&data)?;
    
    Ok(())
}
```

## Platform-Specific Behavior Changes

### Runtime Directory Changes on Linux

**Before (0.1.x):**

- Linux used `/run/user/{uid}` (required unsafe `libc` calls to get UID)

**After (0.2.0):**

- Linux now uses `$TMPDIR` environment variable, falling back to `/tmp`
- Unified behavior with macOS (both platforms now use the same logic)
- No more unsafe code or external dependencies

This change affects the `runtime()` method fallback behavior when `XDG_RUNTIME_DIR` is not set.

## Deprecated Method Migration

**Before (0.1.x):**

```rust
use dir_spec::Dir;

#[allow(deprecated)]
let desktop = Dir::desktop_dir()?;
let documents = Dir::documents_dir()?;
let downloads = Dir::download_dir()?;
let music = Dir::music_dir()?;
let pictures = Dir::pictures_dir()?;
let public = Dir::publicshare_dir()?;
let runtime = Dir::runtime_dir()?;
let templates = Dir::templates_dir()?;
let videos = Dir::videos_dir()?;
```

**After (0.2.0):**

```rust
use dir_spec::Dir;

let desktop = Dir::desktop().ok_or("No desktop directory")?;
let documents = Dir::documents().ok_or("No documents directory")?;
let downloads = Dir::downloads().ok_or("No downloads directory")?;
let music = Dir::music().ok_or("No music directory")?;
let pictures = Dir::pictures().ok_or("No pictures directory")?;
let public = Dir::publicshare().ok_or("No public directory")?;
let runtime = Dir::runtime().ok_or("No runtime directory")?;
let templates = Dir::templates().ok_or("No templates directory")?;
let videos = Dir::videos().ok_or("No videos directory")?;
```

### Simple Replacements

## Error Handling Strategy Changes

If you need more specific error information, you can create custom error types:

**0.2.0 approach:**

```rust
use dir_spec::Dir;
use std::fmt;

#[derive(Debug)]
enum DirError {
    ConfigNotFound,
    CacheNotFound,
    HomeNotFound,
}

impl fmt::Display for DirError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            DirError::ConfigNotFound => write!(f, "Could not determine config directory"),
            DirError::CacheNotFound => write!(f, "Could not determine cache directory"),
            DirError::HomeNotFound => write!(f, "Could not determine home directory"),
        }
    }
}

impl std::error::Error for DirError {}

fn get_config_dir() -> Result<std::path::PathBuf, DirError> {
    Dir::config_home().ok_or(DirError::ConfigNotFound)
}
```

### Custom Error Types

For applications that need multiple directories and want to fail fast:

```rust
use dir_spec::Dir;

fn get_app_directories() -> Option<(std::path::PathBuf, std::path::PathBuf, std::path::PathBuf)> {
    Some((
        Dir::config_home()?,
        Dir::cache_home()?,
        Dir::data_home()?,
    ))
}

// Usage
match get_app_directories() {
    Some((config, cache, data)) => {
        println!("All directories available");
        // use directories
    }
    None => {
        eprintln!("One or more directories could not be determined");
    }
}
```

### Bulk Directory Resolution

Update your tests to handle the new return type:

**Before (0.1.x):**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_config_dir() {
        let config = Dir::config_home().unwrap();
        assert!(config.is_absolute());
    }
}
```

**After (0.2.0):**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_config_dir() {
        let config = Dir::config_home().expect("Config directory should be available");
        assert!(config.is_absolute());
    }
    
    #[test]
    fn test_config_dir_option() {
        // Test that we get Some value in normal circumstances
        assert!(Dir::config_home().is_some());
    }
}
```

## Testing Changes

### 1. Forgetting to Handle None Cases

**Problem:**

```rust
// This will panic if home directory can't be determined
let home = Dir::home().unwrap();
```

**Solution:**

```rust
// Better error handling
let home = Dir::home().expect("Home directory must be available");
// or
let home = Dir::home().ok_or("No home directory")?;
```

### 2. Changed Method Names

**Problem:**

```rust
// This method no longer exists
let downloads = Dir::download_dir();
```

**Solution:**

```rust
// Note the 's' at the end
let downloads = Dir::downloads();
```

### 3. Error Propagation

**Problem:**

```rust
// This won't compile in 0.2.0
fn get_dirs() -> Result<Vec<PathBuf>, eyre::Error> {
    Ok(vec![
        Dir::config_home()?,
        Dir::cache_home()?,
    ])
}
```

**Solution:**

```rust
fn get_dirs() -> Option<Vec<std::path::PathBuf>> {
    Some(vec![
        Dir::config_home()?,
        Dir::cache_home()?,
    ])
}

// Or with custom error handling
fn get_dirs() -> Result<Vec<std::path::PathBuf>, Box<dyn std::error::Error>> {
    Ok(vec![
        Dir::config_home().ok_or("No config dir")?,
        Dir::cache_home().ok_or("No cache dir")?,
    ])
}
```

## Common Gotchas

After migrating to 0.2.0, you'll benefit from:

1. **Simpler dependency management**: No longer need `eyre`
2. **Cleaner error handling**: Option pattern matching is more idiomatic for this use case
3. **Better performance**: Reduced overhead from error type conversions
4. **Consistency**: Aligns with `std::env::home_dir()` return type
5. **Smaller binary size**: Fewer dependencies

## Getting Help

If you encounter issues during migration:

1. Check this migration guide for common patterns
2. Review the updated examples in the README
3. Look at the test cases in the source code for usage patterns
4. Open an issue on GitHub if you find gaps in this guide
